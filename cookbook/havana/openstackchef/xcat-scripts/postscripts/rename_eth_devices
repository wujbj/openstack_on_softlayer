#!/usr/bin/python

# This script should be run in xcat postscripts AFTER custom ethernet device drivers are loaded

# In this script, we first fetch the orignal device-assignment lines from the ##-persistent-net.rules file
# and sort them by mac-address.
# We are then able to apply the renames all at once instead of serially, 
# avoiding the problem of having two of the same "eth#" at the same time while applying the rename rules.

from xml.dom import minidom
import subprocess
import pprint
import os
import sys
import re

def findHostnameMatch(hostname) :
  xmldoc = minidom.parse('/xcatpost/scpsetup/nodelist.xml')
  nodelist = xmldoc.getElementsByTagName('node')
  for node in nodelist :
    print("Node hostname read is " + node.getElementsByTagName('hostname')[0].firstChild.nodeValue );
    if (node.getElementsByTagName('hostname')[0].firstChild.nodeValue == hostname) : 
      return node
  return None;

# Returns the text output of a shell command
def shell_eval(shell_cmd) :
  shellarray = [shell_cmd];
  # Stupid Python 2.6 doesn't have check_output method under subprocess module.
  # return subprocess.check_output(shellarray);
  obj = subprocess.Popen(shellarray,  stderr=subprocess.PIPE,  stdout=subprocess.PIPE,
                           close_fds=True, shell=True);
  result = obj.communicate();
  return result[0];

# Returns mac-address indexed dictionary of the persistent rule lines
def fetch_mac_dict(rules_filename) :
  original_lines = shell_eval('grep "ATTR{address}==" ' + rules_filename)
  mac_dir = {}
  for line in original_lines.split('\n') :
    mac_str = re.sub(r'.*ATTR{address}=="([^"]*)".*', r'\1', line)
    if mac_str != "" :
      mac_dir[mac_str] = line
  pprint.pprint(mac_dir)
  return mac_dir

def rename_eth_adapter(old_interface, new_interface, old_dict, new_dict) :
  if len(old_dict.keys()) == 0 :
    mac_str = shell_eval('ifconfig '+old_interface).split(' ')[4]
    replace_string = 'SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="MAC_ADDR_HERE", ATTR{type}=="1", KERNEL=="eth*", NAME="ETH_IF_HERE"'
    new_string = replace_string.replace('MAC_ADDR_HERE', mac_str).replace('ETH_IF_HERE',new_interface)
    new_dict[mac_str] = new_string

    if os.path.exists('/etc/redhat-release') :
      os.system("mv /etc/sysconfig/network-scripts/ifcfg-"+old_interface+" /etc/sysconfig/network-scripts/ifcfg-"+new_interface+".new")
      os.system('sed "s/'+ old_interface + '/' + new_interface + '/g" -i /etc/sysconfig/network-scripts/ifcfg-'+new_interface+'.new')

  else :
    for mac in old_dict.keys() :
      if old_dict[mac].find('"'+old_interface+'"') != -1 :
        new_dict[mac] = old_dict[mac].replace('"'+old_interface+'"', '"'+new_interface+'"')
        # del old_dict[mac]
        if os.path.exists('/etc/redhat-release') :
          os.system("mv /etc/sysconfig/network-scripts/ifcfg-"+old_interface+" /etc/sysconfig/network-scripts/ifcfg-"+new_interface+".new")
          os.system('sed "s/'+ old_interface + '/' + new_interface + '/g" -i /etc/sysconfig/network-scripts/ifcfg-'+new_interface+'.new')

hostname = shell_eval("/bin/hostname").rstrip() ;

node = findHostnameMatch(hostname);
if ( node == None ):
  hostname = os.environ['NODE'] # Might be that hostname has not been set in the OS, should be provided by /xcatpost/mypostscript
  node = findHostnameMatch(hostname);
  if ( node == None ):
    print "Warning node \"" + hostname +"\" not found in /xcatpost/scpsetup/nodelist.xml";
    sys.exit(1);
 
rules_filename = shell_eval('find /etc/udev/ -name "*-persistent-net.rules"').strip()
if rules_filename == "" :
  rules_filename = '/etc/udev/rules.d/70-persistent-net.rules'

old_dict = fetch_mac_dict(rules_filename)   # original lines
new_dict = {}  # updates lines

configured_if_list = [];
# The install xml-element is used to designate the interface used to PXE boot the system & drive chef over
installlist = node.getElementsByTagName('install');
if ( installlist != None and len(installlist) > 0 ) : 
  original_if = installlist[0].getAttribute('original_if');
  renamed_if = installlist[0].getAttribute('if');
  if original_if != None and original_if != "" :
    rename_eth_adapter(original_if, renamed_if, old_dict, new_dict)
    if os.path.exists('/etc/debian_version') :
      os.system('sed "s/'+ original_if + '/' + renamed_if + '/g" -i /etc/network/interfaces')
    configured_if_list += original_if;

# The rename_eth xml-elements are used to designate the interfaces besides the install interface that should
# be renamed to a different eth#. 
renamelist = node.getElementsByTagName('rename_eth');
if ( renamelist != None and len(renamelist) > 0 ) : 
  for rename_entry in renamelist :
    original_if = rename_entry.getAttribute('original_if');
    renamed_if = rename_entry.getAttribute('if');
    if not any(original_if in s for s in configured_if_list) :
      if original_if != None and original_if != "" :
        rename_eth_adapter(original_if, renamed_if, old_dict, new_dict)
        configured_if_list += original_if

if len(new_dict.keys()) > 0 :
  print "Have some device renames, time to make a new rules file"
  pprint.pprint(new_dict)
  # pprint.pprint(new_dict.keys())
  if os.path.exists('/etc/udev/rules.d/70-persistent-net.rules') :
    fin = open(rules_filename)
    fout = open(rules_filename + ".new", "wt")
    for line in fin :
      mac_str = re.sub(r'.*ATTR{address}=="([^"]*)".*', r'\1', line).strip()
      if mac_str != "" and mac_str in new_dict :
        # print("Replacing matchline for line")
        fout.write( new_dict[mac_str] + '\n' )
      else :
        fout.write( line )
    fin.close()
    fout.close()  
    # Swap in the new rules file
    os.system('mv '+rules_filename+' '+rules_filename+'.old')
    os.system('mv '+rules_filename+'.new '+rules_filename)
  else :  # rules file didn't exist yet
    fout =  open(rules_filename, "wt")
    for k in new_dict.keys() :
      fout.write(new_dict[k] + '\n')
    fout.close()

  print("Finished writing rules file")
  # Copy back in the the ifcfg-*.new files as just ifcfg-* files
  if os.path.exists('/etc/redhat-release') :
    for line in shell_eval("ls /etc/sysconfig/network-scripts/ifcfg*.new").split('\n') :
      if line != "" : 
        # print("processing line: "+line) 
        os.system('mv ' + line + ' ' + line.replace(".new"," "))
    print("Finished moving ifcfg-* files")
